<!doctype html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>黑白棋分析器</title>
  <link rel="icon" type="image/png" href="黑白棋%20icon.png">
  <link rel="shortcut icon" type="image/png" href="黑白棋%20icon.png">
  <style>
    :root {
      --bg: #e8edf5;
      --panel: #ffffff;
      --accent: #0ea27f;
      --accent-2: #0ea5e9;
      --grid: #dbe5f2;
      --line: #c5d0e0;
      --black: #0f172a;
      --white: #f9fafb;
      --text: #1f2937;
      --muted: #4b5563;
      --warn: #f59e0b;
      --danger: #ef4444;
      font-family: "Segoe UI", "Noto Sans TC", system-ui, sans-serif;
    }
    * { box-sizing: border-box; }
    body { margin:0; background: radial-gradient(circle at 20% 20%, rgba(14,162,127,0.18), transparent 30%), radial-gradient(circle at 80% 10%, rgba(14,165,233,0.14), transparent 28%), var(--bg); color: var(--text); min-height:100vh; padding:24px; }
    h1 { margin:0 0 12px; letter-spacing:1px; font-weight:800; display:flex; gap:12px; align-items:center; color:var(--black); }
    h1 span { font-size:14px; font-weight:500; color:var(--muted); }
    .layout { display:grid; grid-template-columns:minmax(260px,360px) 1fr; gap:18px; }
    @media (max-width:960px){ .layout{ grid-template-columns:1fr; } }
    .panel { background: linear-gradient(145deg, rgba(255,255,255,0.98), rgba(255,255,255,0.93)); border:1px solid rgba(15,23,42,0.08); box-shadow:0 10px 40px rgba(15,23,42,0.12); border-radius:16px; padding:16px; }
    .board-and-list { display:grid; grid-template-columns:minmax(420px,1fr) 260px; gap:14px; align-items:start; }
    @media (max-width:1080px){ .board-and-list{ grid-template-columns:1fr; } }
    .section-title { margin:0 0 10px; font-size:16px; color:var(--muted); letter-spacing:0.3px; display:flex; align-items:center; gap:8px; }
    .controls { display:grid; gap:10px; }
    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .pill { background:#eef3fb; border:1px solid var(--line); border-radius:10px; padding:8px 10px; display:inline-flex; gap:8px; align-items:center; }
    label { color:var(--text); font-size:14px; }
    button, select, input[type="text"], textarea { background:var(--grid); color:var(--text); border:1px solid var(--line); border-radius:10px; padding:8px 12px; font-size:14px; transition:transform 120ms ease, border-color 120ms ease, background 120ms ease; }
    button:hover, select:hover, input[type="text"]:hover, textarea:hover { border-color:var(--accent-2); }
    button:active { transform:translateY(1px); }
    button.primary { background:linear-gradient(135deg, var(--accent), #22d3ee); color:#0b0f1a; border-color:transparent; font-weight:700; }
    textarea { width:100%; min-height:110px; resize:vertical; line-height:1.4; }
    .board-wrap { display:grid; gap:10px; justify-items:center; }
    .board-shell { position:relative; display:inline-block; padding:56px 50px 36px 50px; }
    .board { background:#d6e8dd; border:1px solid #b5d0c1; border-radius:12px; padding:10px; box-shadow: inset 0 0 0 1px rgba(15,23,42,0.04); position:relative; }
    .grid { display:grid; gap:6px; }
    @media (max-width:600px){ .grid{ gap:4px; } }
    .cell { position:relative; border-radius:12px; background:linear-gradient(180deg,#2e7c36,#215f28); border:1px solid rgba(15,23,42,0.08); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12); cursor:pointer; transition:transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease; }
    .cell:hover { transform:translateY(-1px); border-color:var(--accent); box-shadow:0 8px 16px rgba(0,0,0,0.2); }
    .disc { position:absolute; inset:8px; border-radius:50%; box-shadow:0 10px 18px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(0,0,0,0.35); }
    .black { background:linear-gradient(135deg,#0d1117,#1f2937); }
    .white { background:linear-gradient(135deg,#f8fafc,#e2e8f0); }
    .hint::after { content:""; position:absolute; inset:18px; border-radius:50%; background: radial-gradient(circle, rgba(16,185,129,0.9), rgba(16,185,129,0.05)); opacity:0.9; }
    .hint.best::after { background: radial-gradient(circle, rgba(14,165,233,0.95), rgba(14,165,233,0.1)); }
    .blocked { background: repeating-linear-gradient(45deg,#304151,#304151 10px,#395062 10px,#395062 20px); border:1px solid #4b5563; }
    .blocked-mark { position:absolute; inset:0; display:grid; place-items:center; font-weight:800; color:#f9fafb; text-shadow:0 1px 2px rgba(0,0,0,0.4); pointer-events:none; }
    .stats { display:grid; grid-template-columns:repeat(auto-fit,minmax(120px,1fr)); gap:10px; }
    .card { border:1px solid var(--line); background:rgba(219,229,242,0.5); border-radius:12px; padding:10px; }
    .big { font-size:26px; font-weight:800; color:var(--black); letter-spacing:0.6px; }
    .muted { color:var(--muted); font-size:13px; }
    .list { max-height:200px; overflow:auto; padding:0; margin:0; list-style:none; border:1px solid var(--line); border-radius:10px; }
    .list li { padding:8px 10px; border-bottom:1px solid rgba(15,23,42,0.06); display:flex; justify-content:space-between; gap:8px; align-items:center; }
    .list li:last-child { border-bottom:none; }
    .pill-badge { padding:4px 8px; border-radius:999px; font-size:12px; color:#0b0f1a; font-weight:700; }
    .badge-green { background:var(--accent); }
    .badge-blue { background:var(--accent-2); }
    .badge-danger { background:var(--danger); }
    .move-panel { min-height:200px; display:flex; flex-direction:column; gap:10px; }
    .hidden { display:none; }
    .eval-wrap { margin:0 0 4px; }
    .eval-label { font-size:13px; color:var(--muted); margin-bottom:4px; }
    .eval-bar { height:12px; border-radius:999px; background:var(--grid); border:1px solid var(--line); overflow:hidden; position:relative; }
    .eval-fill { position:absolute; inset:0; width:50%; border-radius:999px; background:linear-gradient(90deg,#111827,var(--accent)); transition:width 160ms ease, background 160ms ease; }
    .file-labels, .rank-labels { position:absolute; color:var(--muted); font-size:12px; pointer-events:none; font-weight:700; letter-spacing:0.5px; }
    .file-labels { left:50px; right:50px; display:grid; grid-auto-flow:column; grid-auto-columns:1fr; text-align:center; }
    .file-top { top:26px; }
    .file-bottom { bottom:8px; }
    .rank-labels { top:24px; bottom:24px; display:grid; grid-auto-rows:1fr; align-items:center; }
    .rank-left { left:8px; text-align:right; }
    .rank-right { right:8px; text-align:left; }
    .turn-banner { position:absolute; top:30px; left:50%; transform:translateX(-50%); background:rgba(255,255,255,0.9); border:1px solid var(--line); border-radius:999px; padding:6px 12px; display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted); box-shadow:0 4px 10px rgba(0,0,0,0.08); user-select:none; cursor:pointer; z-index:10; }
    .turn-banner .active { color:var(--accent); font-weight:800; }
  </style>
</head>
<body>
  <h1>黑白棋分析器 <span>可編輯盤面 / 合法落點 / 簡易評估 / 禁手格</span></h1>
  <div class="layout">
    <section class="panel">
      <div class="section-title">盤面控制</div>
      <div class="controls">
        <div class="row">
          <span class="pill">
            <label><input type="radio" name="turn" value="B" checked> 黑先</label>
            <label><input type="radio" name="turn" value="W"> 白先</label>
          </span>
          <label class="pill"><input type="checkbox" id="editMode"> 編輯模式（點擊循環空/黑/白/禁手）</label>
          <label class="pill"><input type="checkbox" id="showHints" checked> 顯示合法落點提示</label>
        </div>
        <div class="row">
          <button class="primary" id="resetBtn">重設開局</button>
          <button id="clearBtn">清空盤面</button>
          <button id="swapBtn">交換行棋方</button>
          <button id="rotateBtn">旋轉90°</button>
          <button id="undoBtn">悔棋</button>
          <button id="toggleRoleBtn">切換玩家/AI</button>
        </div>
        <div class="row">
          <button id="copyBtn">複製盤面字串</button>
          <button id="loadBtn">匯入盤面</button>
        </div>
        <div class="row">
          <span class="pill">
            <label for="modeSelect">對戰模式</label>
            <select id="modeSelect">
              <option value="pvp">玩家互打</option>
              <option value="pvai">玩家 vs AI</option>
            </select>
          </span>
          <span class="pill">
            <label for="aiSide">AI 顏色</label>
            <select id="aiSide">
              <option value="B">黑</option>
              <option value="W" selected>白</option>
            </select>
          </span>
        </div>
        <div class="row">
          <label class="pill"><input type="checkbox" id="showList" checked> 顯示右側分析區</label>
        </div>
        <div class="row">
          <span class="pill">
            <label>行數 <input type="number" id="rowsInput" min="4" max="26" value="8" style="width:64px;"></label>
          </span>
          <span class="pill">
            <label>列數 <input type="number" id="colsInput" min="4" max="26" value="8" style="width:64px;"></label>
          </span>
          <button id="applySizeBtn">套用棋盤大小</button>
        </div>
        <textarea id="boardText" placeholder="8 行，每行 8 個字元：. 空格、B 黑、W 白、X 禁手。例如開局：
........
........
........
...WB...
...BW...
........
........
........"></textarea>
      </div>
    </section>

    <section class="panel">
      <div class="board-and-list">
          
        <div class="board-wrap">
          <div class="turn-banner" id="turnBanner">
            <span id="blackRole">黑：玩家</span>
            <span id="whiteRole">白：玩家</span>
            <span id="currentTurn">現在：黑</span>
          </div>
          <div class="board-shell">
          
            <div class="board">
              <div id="grid" class="grid"></div>
            </div>
            <div class="file-labels file-top" id="fileTop"></div>
            <div class="file-labels file-bottom" id="fileBottom"></div>
            <div class="rank-labels rank-left" id="rankLeft"></div>
            <div class="rank-labels rank-right" id="rankRight"></div>
          </div>
        </div>
        <div class="move-panel" id="movePanel">
          <div class="section-title">分析</div>
          <div class="stats">
            <div class="card">
              <div class="muted">黑子</div>
              <div class="big" id="blackCount">2</div>
            </div>
            <div class="card">
              <div class="muted">白子</div>
              <div class="big" id="whiteCount">2</div>
            </div>
            <div class="card">
              <div class="muted">合法步數</div>
              <div class="big" id="legalCount">4</div>
            </div>
            <div class="card">
              <div class="muted">建議</div>
              <div class="big" id="bestMove">-</div>
            </div>
          </div>
          <div class="eval-wrap">
            <div class="eval-label" id="evalLabel">平衡</div>
            <div class="eval-bar"><div class="eval-fill" id="evalFill"></div></div>
          </div>

          <div class="section-title" style="margin-top:4px;">合法落點詳情</div>
          <ul class="list" id="moveList"></ul>
        </div>
      </div>
    </section>
  </div>

  <section class="panel" style="margin-top: 12px;">
    <div class="section-title">說明</div>
    <p class="muted" style="margin:0 0 6px;">．一般模式：點空格下子並自動翻轉；遇到禁手格（X）不能下。</p>
    <p class="muted" style="margin:0 0 6px;">．對戰模式：玩家互打或玩家 vs AI，可選 AI 顏色；若輪到 AI 會自動落子（或按「AI 下棋」立即執行）。</p>
    <p class="muted" style="margin:0 0 6px;">．編輯模式：點擊循環空 → 黑 → 白 → 禁手（X） → 空，用來排盤或設定禁止落子格。</p>
    <p class="muted" style="margin:0 0 6px;">．匯入格式為 8 行 8 字元，支援 . / 0 / 空白 代表空格，B/W 代表棋子，X 代表禁手。</p>
    <p class="muted" style="margin:0;">．評估為簡易啟發式：角落加權、行棋方可行步數、翻子數量。</p>
  </section>

  <script>
    let ROWS = 8;
    let COLS = 8;
    const DIRS = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
    const EDIT_STATES = [".","B","W","X"];
    const BASE_WEIGHT_8X8 = [
      [120,-20,20,5,5,20,-20,120],
      [-20,-40,-5,-5,-5,-5,-40,-20],
      [20,-5,15,3,3,15,-5,20],
      [5,-5,3,3,3,3,-5,5],
      [5,-5,3,3,3,3,-5,5],
      [20,-5,15,3,3,15,-5,20],
      [-20,-40,-5,-5,-5,-5,-40,-20],
      [120,-20,20,5,5,20,-20,120]
    ];

    const gridEl = document.getElementById("grid");
    const blackCountEl = document.getElementById("blackCount");
    const whiteCountEl = document.getElementById("whiteCount");
    const legalCountEl = document.getElementById("legalCount");
    const bestMoveEl = document.getElementById("bestMove");
    const moveListEl = document.getElementById("moveList");
    const editModeEl = document.getElementById("editMode");
    const showHintsEl = document.getElementById("showHints");
    const boardTextEl = document.getElementById("boardText");
    const turnRadios = Array.from(document.querySelectorAll('input[name="turn"]'));
    const modeSelect = document.getElementById("modeSelect");
    const aiSideSelect = document.getElementById("aiSide");
    const turnBannerEl = document.getElementById("turnBanner");
    const blackRoleEl = document.getElementById("blackRole");
    const whiteRoleEl = document.getElementById("whiteRole");
    const currentTurnEl = document.getElementById("currentTurn");

    const movePanel = document.getElementById("movePanel");
    const showListEl = document.getElementById("showList");
    const evalFill = document.getElementById("evalFill");
    const evalLabel = document.getElementById("evalLabel");
    const bestSummaryEl = document.getElementById("bestSummary");
    const toggleRoleBtn = document.getElementById("toggleRoleBtn");
    const fileTopEl = document.getElementById("fileTop");
    const fileBottomEl = document.getElementById("fileBottom");
    const rankLeftEl = document.getElementById("rankLeft");
    const rankRightEl = document.getElementById("rankRight");
    const rowsInput = document.getElementById("rowsInput");
    const colsInput = document.getElementById("colsInput");
    const applySizeBtn = document.getElementById("applySizeBtn");

    const undoStack = [];
    let weightMatrix = buildWeightMatrix(ROWS, COLS);
    let board = createInitial();
    let currentPlayer = "B";

    function buildWeightMatrix(r,c){
      if(r===8 && c===8){
        return BASE_WEIGHT_8X8.map(row=>row.slice());
      }
      return Array.from({length:r},(_,ri)=>Array.from({length:c},(_,ci)=>{
        const distEdge = Math.min(ri, ci, r-1-ri, c-1-ci);
        const corner = (ri===0||ri===r-1) && (ci===0||ci===c-1);
        const nearCorner = distEdge===1;
        let w = (Math.min(r,c)-distEdge)*4;
        if(corner) w += 100;
        else if(nearCorner) w -= 25;
        return w;
      }));
    }

    function createInitial(){
      const b = Array.from({length:ROWS},()=>Array(COLS).fill("."));
      const r1 = Math.floor((ROWS-1)/2), r2 = Math.min(r1+1, ROWS-1);
      const c1 = Math.floor((COLS-1)/2), c2 = Math.min(c1+1, COLS-1);
      b[r1][c1]="W"; b[r1][c2]="B"; b[r2][c1]="B"; b[r2][c2]="W";
      return b;
    }
    const inBounds=(r,c)=>r>=0&&c>=0&&r<ROWS&&c<COLS;
    const opposite=p=>p==="B"?"W":"B";
    function letterFor(col){
      const A=65; let n=col; let s="";
      do { s=String.fromCharCode(A+(n%26))+s; n=Math.floor(n/26)-1; } while(n>=0);
      return s;
    }

    function findFlips(b,r,c,p){
      if(b[r][c]!==".") return [];
      const flips=[];
      for(const [dr,dc] of DIRS){
        const line=[]; let nr=r+dr,nc=c+dc;
        while(inBounds(nr,nc)&&b[nr][nc]===opposite(p)){ line.push([nr,nc]); nr+=dr; nc+=dc; }
        if(inBounds(nr,nc)&&b[nr][nc]===p&&line.length) flips.push(...line);
      }
      return flips;
    }
    function legalMoves(b,p){
      const res=[];
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const flips=findFlips(b,r,c,p); if(flips.length) res.push({r,c,flips});
      }
      return res;
    }
    function applyMove(b,r,c,p,flips){
      const next=b.map(row=>row.slice());
      next[r][c]=p; for(const [fr,fc] of flips) next[fr][fc]=p; return next;
    }
    function count(b){ let black=0,white=0; for(const row of b){ for(const cell of row){ if(cell==="B") black++; else if(cell==="W") white++; } } return {black,white}; }
    function scoreBoard(b,p){
      const moves=legalMoves(b,p); let score=moves.length*8;
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(b[r][c]===p) score+=weightMatrix[r][c];
      return score;
    }
    function bestMoveFn(b,p){
      const moves=legalMoves(b,p); if(!moves.length) return null; let best=null;
      for(const m of moves){ const nb=applyMove(b,m.r,m.c,p,m.flips); const s=scoreBoard(nb,p)-scoreBoard(nb,opposite(p))+m.flips.length*2; if(!best||s>best.score) best={...m,score:s}; }
      return best;
    }
    const coordLabel=(r,c)=>letterFor(c)+(r+1);

    function pushUndo(){
      undoStack.push({board:board.map(row=>row.slice()), player:currentPlayer, rows:ROWS, cols:COLS});
      if(undoStack.length>30) undoStack.shift();
    }
    function rotateBoard90(b){
      const n=Array.from({length:COLS},()=>Array(ROWS).fill('.'));
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) n[c][ROWS-1-r]=b[r][c];
      return n;
    }
    function roleLabel(side){ return modeSelect.value==="pvai" ? (aiSideSelect.value===side?"AI":"玩家") : "玩家"; }
    function updateBanner(){ if(!turnBannerEl) return; const br=roleLabel("B"), wr=roleLabel("W"); if(blackRoleEl) blackRoleEl.textContent=`黑：${br}`; if(whiteRoleEl) whiteRoleEl.textContent=`白：${wr}`; if(currentTurnEl) currentTurnEl.textContent=`現在：${currentPlayer==="B"?"黑":"白"}`; if(blackRoleEl) blackRoleEl.classList.toggle("active",currentPlayer==="B"); if(whiteRoleEl) whiteRoleEl.classList.toggle("active",currentPlayer==="W"); if(currentTurnEl) currentTurnEl.classList.add("active"); }
    function updateEval(diff){ const capped=Math.max(-400,Math.min(400,diff)); const pct=Math.round((capped/800+0.5)*100); if(evalFill){ evalFill.style.width=pct+"%"; evalFill.style.background = pct>=50 ? "linear-gradient(90deg,#111827,var(--accent))" : "linear-gradient(90deg,#e5e7eb,var(--accent-2))"; } let label="平衡"; if(diff>60) label=`黑優勢 (+${diff.toFixed(0)})`; else if(diff<-60) label=`白優勢 (${diff.toFixed(0)})`; else label=`平衡 (${diff.toFixed(0)})`; if(evalLabel) evalLabel.textContent=label; }
    function toggleRoles(){
      if(modeSelect.value!=="pvai"){
        modeSelect.value="pvai";
        aiSideSelect.value="W";
      } else {
        aiSideSelect.value = aiSideSelect.value==="B" ? "W" : "B";
      }
      updateBanner();
      render();
      autoPlayIfNeeded();
    }

    function updateLabels(){
      if(fileTopEl) fileTopEl.style.gridTemplateColumns = `repeat(${COLS},1fr)`;
      if(fileBottomEl) fileBottomEl.style.gridTemplateColumns = `repeat(${COLS},1fr)`;
      if(rankLeftEl) rankLeftEl.style.gridTemplateRows = `repeat(${ROWS},1fr)`;
      if(rankRightEl) rankRightEl.style.gridTemplateRows = `repeat(${ROWS},1fr)`;
      const files = Array.from({length:COLS},(_,i)=>`<span>${letterFor(i)}</span>`).join("");
      const ranks = Array.from({length:ROWS},(_,i)=>`<span>${i+1}</span>`).join("");
      if(fileTopEl) fileTopEl.innerHTML = files;
      if(fileBottomEl) fileBottomEl.innerHTML = files;
      if(rankLeftEl) rankLeftEl.innerHTML = ranks;
      if(rankRightEl) rankRightEl.innerHTML = ranks;
    }

    function updateGridTemplate(){
      const small = window.matchMedia("(max-width:600px)").matches;
      const size = small ? 38 : 52;
      gridEl.style.gridTemplateColumns = `repeat(${COLS}, ${size}px)`;
      gridEl.style.gridTemplateRows = `repeat(${ROWS}, ${size}px)`;
    }

    function syncSizeInputs(){
      if(rowsInput) rowsInput.value = ROWS;
      if(colsInput) colsInput.value = COLS;
    }

    function applyBoardSize(){
      const r = parseInt(rowsInput.value,10);
      const c = parseInt(colsInput.value,10);
      if(!Number.isInteger(r)||!Number.isInteger(c)||r<4||c<4||r>26||c>26){
        alert("行列需在 4~26 的整數範圍");
        return;
      }
      ROWS = r; COLS = c;
      weightMatrix = buildWeightMatrix(ROWS, COLS);
      board = createInitial();
      currentPlayer = "B";
      undoStack.length = 0;
      render(); autoPlayIfNeeded();
    }

    function render(){
      gridEl.innerHTML="";
      syncSizeInputs();
      updateGridTemplate();
      updateLabels();
      const moves=legalMoves(board,currentPlayer);
      const hints=new Map(); moves.forEach(m=>hints.set(`${m.r},${m.c}`,m));
      const best=bestMoveFn(board,currentPlayer); const bestKey=best?`${best.r},${best.c}`:null;
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const cell=document.createElement("div"); cell.className="cell"; const val=board[r][c];
        if(val==="B"||val==="W"){ const d=document.createElement("div"); d.className="disc "+(val==="B"?"black":"white"); cell.appendChild(d); }
        else if(val==="X"){ cell.classList.add("blocked"); const mark=document.createElement("div"); mark.className="blocked-mark"; mark.textContent="X"; cell.appendChild(mark); }
        else if(showHintsEl.checked && hints.has(`${r},${c}`)){ cell.classList.add("hint"); if(bestKey===`${r},${c}`) cell.classList.add("best"); }
        cell.addEventListener("click",()=>onCellClick(r,c));
        gridEl.appendChild(cell);
      }
      const {black,white}=count(board); blackCountEl.textContent=black; whiteCountEl.textContent=white; legalCountEl.textContent=moves.length; bestMoveEl.textContent=best?coordLabel(best.r,best.c):"-";
      const evalDiff=scoreBoard(board,"B")-scoreBoard(board,"W"); updateEval(evalDiff); updateBanner();
      moveListEl.innerHTML="";
      if(!moves.length){ const li=document.createElement("li"); li.innerHTML=`<span>無合法著法</span><span class="pill-badge badge-danger">PASS</span>`; moveListEl.appendChild(li); }
      else {
        const scored=moves.map(m=>{ const nb=applyMove(board,m.r,m.c,currentPlayer,m.flips); const score=scoreBoard(nb,currentPlayer)-scoreBoard(nb,opposite(currentPlayer))+m.flips.length*2; return {...m,score}; });
        scored.sort((a,b)=>b.score-a.score).forEach(m=>{ const li=document.createElement("li"); const label=coordLabel(m.r,m.c); const flips=m.flips.length; const tag=bestKey===`${m.r},${m.c}`?'<span class="pill-badge badge-blue">最佳</span>':'<span class="pill-badge badge-green">合法</span>'; li.innerHTML=`<span>${label}</span><span class="muted">翻 ${flips} 子，估分 ${m.score.toFixed(0)}</span>${tag}`; moveListEl.appendChild(li); });
      }
      if(boardTextEl){
        boardTextEl.value=board.map(r=>r.join("")).join("\n");
        boardTextEl.placeholder=`${ROWS} 行，每行 ${COLS} 個字元：. 空格、B 黑、W 白、X 禁手。`;
      }
      turnRadios.forEach(r=>r.checked = r.value===currentPlayer);
      movePanel.classList.toggle("hidden", !showListEl.checked);
    }

    const isAITurn=()=>modeSelect.value==="pvai" && currentPlayer===aiSideSelect.value;
    const autoPlayIfNeeded=()=>{ if(!isAITurn()) return; setTimeout(()=>{ if(isAITurn()) aiMove(); },120); };

    function finishTurn(triggerAuto=true){
      currentPlayer=opposite(currentPlayer);
      if(!legalMoves(board,currentPlayer).length){ currentPlayer=opposite(currentPlayer); if(!legalMoves(board,currentPlayer).length){ render(); return; } }
      render(); if(triggerAuto) autoPlayIfNeeded();
    }

    function aiMove(){
      const moves=legalMoves(board,currentPlayer);
      if(!moves.length){ currentPlayer=opposite(currentPlayer); if(!legalMoves(board,currentPlayer).length){ render(); return; } render(); autoPlayIfNeeded(); return; }
      const pick=bestMoveFn(board,currentPlayer)||moves[0]; pushUndo(); board=applyMove(board,pick.r,pick.c,currentPlayer,pick.flips); finishTurn(true);
    }

    function onCellClick(r,c){
      if(editModeEl.checked){ const idx=EDIT_STATES.indexOf(board[r][c]); board[r][c]=EDIT_STATES[(idx+1)%EDIT_STATES.length]; render(); return; }
      if(board[r][c]!==".") return; const flips=findFlips(board,r,c,currentPlayer); if(!flips.length) return; pushUndo(); board=applyMove(board,r,c,currentPlayer,flips); finishTurn(true);
    }

    function resetBoard(){ board=createInitial(); currentPlayer="B"; render(); autoPlayIfNeeded(); }
    function clearBoard(){ board=Array.from({length:ROWS},()=>Array(COLS).fill(".")); render(); autoPlayIfNeeded(); }

    function loadFromText(){
      const lines=boardTextEl.value.trim().split(/\r?\n/).filter(Boolean);
      if(lines.length!==ROWS||lines.some(l=>l.trim().length!==COLS)){ alert(`格式錯誤：需要 ${ROWS} 行，每行 ${COLS} 個字元。`); return; }
      const b=Array.from({length:ROWS},()=>Array(COLS).fill("."));
      for(let r=0;r<ROWS;r++){
        const line=lines[r].trim();
        for(let c=0;c<COLS;c++){
          const ch=line[c].toUpperCase();
          if(ch==='.'||ch==='0'||ch===' ') b[r][c]='.';
          else if(ch==='B'||ch==='W'||ch==='X') b[r][c]=ch;
          else { alert("無效字元: "+ch); return; }
        }
      }
      pushUndo(); board=b; render(); autoPlayIfNeeded();
    }

    function copyBoard(){ navigator.clipboard.writeText(boardTextEl.value).then(()=>{ const old=boardTextEl.value; boardTextEl.value=old+"\n(已複製)"; setTimeout(()=>{ boardTextEl.value=old; },600); }).catch(()=>alert("複製失敗，可能因為瀏覽器限制.")); }

    document.getElementById("resetBtn").addEventListener("click", resetBoard);
    document.getElementById("clearBtn").addEventListener("click", clearBoard);
    document.getElementById("swapBtn").addEventListener("click", () => { currentPlayer=opposite(currentPlayer); render(); autoPlayIfNeeded(); });
    document.getElementById("undoBtn").addEventListener("click", () => {
      const last=undoStack.pop();
      if(!last) return;
      board=last.board;
      currentPlayer=last.player;
      ROWS = last.rows;
      COLS = last.cols;
      weightMatrix = buildWeightMatrix(ROWS, COLS);
      render();
      autoPlayIfNeeded();
    });
    document.getElementById("rotateBtn").addEventListener("click", () => {
      pushUndo();
      board=rotateBoard90(board);
      [ROWS, COLS] = [COLS, ROWS];
      weightMatrix = buildWeightMatrix(ROWS, COLS);
      syncSizeInputs();
      render();
      autoPlayIfNeeded();
    });
    document.getElementById("loadBtn").addEventListener("click", loadFromText);
    document.getElementById("copyBtn").addEventListener("click", copyBoard);
    turnRadios.forEach(r=>r.addEventListener("change", e=>{ currentPlayer=e.target.value; render(); autoPlayIfNeeded(); }));
    editModeEl.addEventListener("change", () => render());
    showHintsEl.addEventListener("change", () => render());
    showListEl.addEventListener("change", () => render());
    modeSelect.addEventListener("change", () => { updateBanner(); autoPlayIfNeeded(); });
    aiSideSelect.addEventListener("change", () => { updateBanner(); autoPlayIfNeeded(); });
    if(applySizeBtn){ applySizeBtn.addEventListener("click", applyBoardSize); }
    if(toggleRoleBtn){ toggleRoleBtn.addEventListener("click", () => toggleRoles()); }
    if(currentTurnEl){ currentTurnEl.addEventListener("click", (e)=>{ e.stopPropagation(); currentPlayer = currentPlayer==="B"?"W":"B"; render(); autoPlayIfNeeded(); }); }
    window.addEventListener("resize", updateGridTemplate);

    resetBoard();
  </script>
</body>
</html>
