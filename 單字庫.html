<!DOCTYPE html>
<html lang="UTF-8">
<head>
  <meta charset="UTF-8">
  <title></title>
  <style>
  body {
   font-family: Arial, sans-serif;
    margin: 0px 10px 10px 10px;
  }
    .container {
      display: flex;
      gap: 10px;
    }
    .left-panel {
      flex: 1;
    }
    .right-panel {
      flex: 1;
      position: sticky;
      margin-top: -5.0em;
      align-self: flex-start;
    }
    .word-list {
      max-height: 70vh;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 5px;
    }
    .word-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      border-bottom: 1px solid #eee;
    }
    .word-item:last-child {
      border-bottom: none;
    }
    /* ***** ä¿®æ”¹é» 1: info-button å±¤ç´šæé«˜çš„ CSS ***** */
    .word-item-info {
        flex-grow: 1;
        position: relative;
        display: flex; /* è®“å…§å®¹æ°´å¹³æ’åˆ— */
        align-items: center; /* å‚ç›´å±…ä¸­ */
    }
    .word-info-text { /* ***** æ–°å¢ class ä¾†åŒ…è£¹æ–‡å­—ä¿¡æ¯ ***** */
        flex-grow: 1;
    }
    .info-button {
        /* background: none; */ /* ç§»é™¤ï¼Œä»¥é˜²è¦†è“‹ */
        /* border: none; */ /* ç§»é™¤ï¼Œä»¥é˜²è¦†è“‹ */
        color: #666;
        cursor: pointer;
        padding: 0 5px;
        font-size: 14px;
        /* ***** å°‡æŒ‰éˆ•ç§»åˆ°æœ€å‰é¢ï¼Œä¸¦çµ¦äºˆå›ºå®šå¯¬åº¦ï¼Œä½¿å…¶ä¸å½±éŸ¿æ–‡å­—ä½ˆå±€ ***** */
        order: -1; /* å°‡æŒ‰éˆ•æ”¾åœ¨ flex å®¹å™¨çš„æœ€å‰é¢ */
        flex-shrink: 0; /* é˜²æ­¢æŒ‰éˆ•ç¸®å° */
        width: 20px; /* å›ºå®šå¯¬åº¦ï¼Œä¿æŒä¸€è‡´æ€§ */
        height: 20px; /* å›ºå®šé«˜åº¦ */
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%; /* åœ“å½¢æŒ‰éˆ• */
        background-color: #f0f0f0; /* æ·ºç°è‰²èƒŒæ™¯ */
        border: 1px solid #ccc; /* é‚Šæ¡† */
        box-sizing: border-box; /* åŒ…å« padding å’Œ border åœ¨å¯¬é«˜å…§ */
    }
    .info-button:hover {
        color: #333;
        background-color: #e0e0e0; /* hover é¡è‰² */
    }
    .stats-tooltip {
    display: none;
    position: absolute; /* ä¿æŒ absolute å®šä½ */
    background: white;
    border: 1px solid #ccc;
    padding: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    z-index: 1000;
    min-width: 150px;
    max-width: 250px; /* è¨­ç½®æœ€å¤§å¯¬åº¦ */
    white-space: normal; /* å…è¨±æ–‡å­—æ›è¡Œ */

    /* ç§»é™¤æˆ–è¨»é‡‹æ‰é€™äº›ç”± JS å‹•æ…‹è¨­ç½®çš„å±¬æ€§ï¼Œæˆ–è€…å°‡å®ƒå€‘è¨­ç‚ºåˆå§‹å€¼ */
    /* left: 30px;  */
    /* top: 0; */
    /* margin-left: 5px; */

    pointer-events: none; /* è®“æ»‘é¼ å¯ä»¥ç©¿é€ */
    opacity: 0;
    transition: opacity 0.2s ease-in-out; /* ä¿æŒéæ¸¡æ•ˆæœ */
}


    .info-button:hover + .stats-tooltip {
        display: block;
        opacity: 1;
    }

    .word-item-actions {
        display: flex;
        gap: 5px;
    }
    .save-buttons {
      margin: 20px 0;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 5px;
    }
    .save-buttons button {
      margin-right: 10px;
    }
    button {
    padding: 5px 10px;
    cursor: pointer;
    transition: background-color 0.3s ease, opacity 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    border-radius: 3px;
  }

  .save-button-dirty {
    background-color: #007bff;
    color: white;
    border: 1px solid #0056b3;
    opacity: 1;
  }

  .save-button-clean {
    background-color: #e0e0e0;
    color: #333;
    border: 1px solid #b0b0b0;
    opacity: 0.7;
  }

  .danger-button {
      background-color: red;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
  }
    input[type="text"], input[type="number"] {
      padding: 5px;
      margin: 5px 0;
      width: 200px;
    }
    textarea {
      width: 100%;
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <h1 id="mainTitle"></h1>
  <p id="saveReminder"></p>
  <button id="langToggleBtn" onclick="toggleLanguage()">ğŸŒ åˆ‡æ›èªè¨€</button>
  <div class="container">

    <div class="left-panel">
      <div>
        <h2 id="bulkAndBackupTitle"></h2>
        <textarea id="dataTextarea" rows="10" cols="50"></textarea><br>
        <div>
            <button onclick="bulkImportFromTextarea()" id="bulkImportBtn"></button>
            <button onclick="exportAllData()" id="exportDataBtn"></button>
            <button onclick="importAllData()" id="importDataBtn"></button>
        </div>
      </div>

      <hr>

      <div>
        <h2 id="gameSettingsTitle"></h2>
        <div style="margin-bottom: 10px;">
          <label for="wordsPerRound" id="wordsPerRoundLabel"></label>
          <input type="number" id="wordsPerRound" min="1" value="10">
        </div>

        <div style="margin-bottom: 10px;">
          <label>
            <input type="checkbox" id="enableWeightSystem">
            <span id="enableWeightSystemLabel"></span>
          </label>
        </div>

        <div>
          <button class="button" onclick="resetAllWrongCounts()">
            <span id="resetWeightsButtonText"></span>
          </button>
        </div>
      </div>

      <div class="save-buttons">
        <button id="saveAllButton" onclick="saveAll()"></button>
        <button class="danger-button" id="clearAllWordsButton" onclick="clearAllWords()"></button>
      </div>

    </div>

    <div class="right-panel">
      <h2 id="wordListSectionTitle"></h2>
      <div style="margin-bottom: 10px;">
          <label for="sortOrder" id="sortOrderLabel"></label>
          <select id="sortOrder" onchange="renderWords()">
            <option value="accuracy_asc" id="sortAccuracyAscOption"></option>
            <option value="accuracy_desc" id="sortAccuracyDescOption"></option>
              <option value="alphabetical_asc" id="sortAlphabeticalAscOption"></option>
              <option value="alphabetical_desc" id="sortAlphabeticalDescOption"></option>
          </select>
      </div>
      <div class="word-list" id="wordList"></div>
      <div id="noWordsInWordBankMessage" style="display: none; text-align: center; padding: 20px; color: #666; font-size: 1.1em;">
          <p id="noWordsBankText"></p>
      </div>
    </div>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    let currentLanguage = urlParams.get('lang') || 'zh';

    let words = JSON.parse(localStorage.getItem('words')) || [];
    words = words.map(wordItem => {
        return {
            word: wordItem.word,
            translation: wordItem.translation,
            wrongCount: wordItem.wrongCount !== undefined ? wordItem.wrongCount : 0,
            correctCount: wordItem.correctCount !== undefined ? wordItem.correctCount : 0,
            hasBeenTested: wordItem.hasBeenTested !== undefined ? wordItem.hasBeenTested : false,
            // ***** ä¿®æ”¹é» 2: é€£å‹è¨ˆæ•¸åˆå§‹åŒ–æ™‚è¨­ç‚º 0 *****
            streakCount: wordItem.streakCount !== undefined ? wordItem.streakCount : 0
        };
    });

    let settings = JSON.parse(localStorage.getItem('wordGameSettings')) || {
        wordsPerRound: 10,
        enableWeightSystem: true
    };

    let originalWords;
    let originalSettings;

    let needsSave = false;
    const saveAllButton = document.getElementById('saveAllButton');
    const saveReminderElement = document.getElementById('saveReminder');

    function updateSaveButtonState() {
      const t = translations[currentLanguage];
      if (needsSave) {
        saveAllButton.classList.remove('save-button-clean');
        saveAllButton.classList.add('save-button-dirty');
        saveReminderElement.textContent = t.reminder;
      } else {
        saveAllButton.classList.remove('save-button-dirty');
        saveAllButton.classList.add('save-button-clean');
        saveReminderElement.textContent = '';
      }
    }

    function markAsNeedsSave() {
      const currentWordsString = JSON.stringify(words);
      const currentWordsPerRound = parseInt(document.getElementById('wordsPerRound').value);
      const currentEnableWeightSystem = document.getElementById('enableWeightSystem').checked;

      const currentSettings = {
          wordsPerRound: currentWordsPerRound,
          enableWeightSystem: currentEnableWeightSystem
      };
      const currentSettingsString = JSON.stringify(currentSettings);

      const originalWordsString = JSON.stringify(originalWords);
      const originalSettingsString = JSON.stringify(originalSettings);

      const hasChanges = (currentWordsString !== originalWordsString) || (currentSettingsString !== originalSettingsString);

      if (hasChanges && !needsSave) {
        needsSave = true;
        updateSaveButtonState();
      } else if (!hasChanges && needsSave) {
        needsSave = false;
        updateSaveButtonState();
      }
    }

    // New function to sort words
    function sortWords(sortOption) {
        if (sortOption === 'accuracy_desc') {
            words.sort((a, b) => {
                const totalA = a.correctCount + a.wrongCount;
                // ***** ä¿®æ”¹é» 3: ç†Ÿç·´åº¦è¨ˆç®—å…¬å¼æ›´æ”¹ *****
                const proficiencyA = totalA > 0 ? (a.correctCount + (a.streakCount > 0 ? (a.streakCount - 1) * 0.2 : 0)) / (totalA * (a.wrongCount + 1)) : 0;
                const totalB = b.correctCount + b.wrongCount;
                const proficiencyB = totalB > 0 ? (b.correctCount + (b.streakCount > 0 ? (b.streakCount - 1) * 0.2 : 0)) / (totalB * (b.wrongCount + 1)) : 0;
                return proficiencyB - proficiencyA; // Descending
            });
        } else if (sortOption === 'accuracy_asc') {
            words.sort((a, b) => {
                const totalA = a.correctCount + a.wrongCount;
                // ***** ä¿®æ”¹é» 3: ç†Ÿç·´åº¦è¨ˆç®—å…¬å¼æ›´æ”¹ *****
                const proficiencyA = totalA > 0 ? (a.correctCount + (a.streakCount > 0 ? (a.streakCount - 1) * 0.2 : 0)) / (totalA * (a.wrongCount + 1)) : 0;
                const totalB = b.correctCount + b.wrongCount;
                const proficiencyB = totalB > 0 ? (b.correctCount + (b.streakCount > 0 ? (b.streakCount - 1) * 0.2 : 0)) / (totalB * (b.wrongCount + 1)) : 0;
                return proficiencyA - proficiencyB; // Ascending
            });
        } else if (sortOption === 'alphabetical_asc') {
            words.sort((a, b) => a.word.localeCompare(b.word)); // Alphabetical A-Z
        } else if (sortOption === 'alphabetical_desc') {
            words.sort((a, b) => b.word.localeCompare(a.word)); // Alphabetical Z-A
        } else {
            words.sort((a, b) => a.word.localeCompare(b.word)); // Fallback to A-Z
        }
    }

    function renderWords() {
        const wordList = document.getElementById('wordList');
        const noWordsMessageDiv = document.getElementById('noWordsInWordBankMessage');
        const noWordsBankText = document.getElementById('noWordsBankText');
        const t = translations[currentLanguage];

        const sortOption = document.getElementById('sortOrder').value;
        sortWords(sortOption);

        if (words.length === 0) {
            wordList.innerHTML = '';
            wordList.style.display = 'none';
            const bulkAndBackupTitleText = document.getElementById('bulkAndBackupTitle').textContent;
            noWordsBankText.innerHTML = `${t.noWordsInBank}<br>${t.promptToAddWordsInBankDynamic.replace('{0}', bulkAndBackupTitleText)}`;
            noWordsMessageDiv.style.display = 'block';
        } else {
            noWordsMessageDiv.style.display = 'none';
            wordList.style.display = 'block';
            wordList.innerHTML = '';

            words.forEach((item, index) => { // <-- é€™å€‹æ˜¯æ­£ç¢ºçš„ forEach å¾ªç’°
                const div = document.createElement('div');
                div.className = 'word-item';

                const totalAttempts = item.correctCount + item.wrongCount;
                // ç†Ÿç·´åº¦è¨ˆç®—å…¬å¼
                const proficiencyRate = totalAttempts > 0 ?
                    ((item.correctCount + (item.streakCount > 0 ? (item.streakCount - 1) * 0.2 : 0)) / (totalAttempts * (item.wrongCount + 1)) * 100).toFixed(0) : 0;

                const infoSpan = document.createElement('span');
                infoSpan.className = 'word-item-info';

                // HTML çµæ§‹èª¿æ•´ï¼Œinfo-button åœ¨æ–‡å­—ä¿¡æ¯ä¹‹å‰
                infoSpan.innerHTML = `
                    <button class="info-button">â“˜</button>
                    <div class="stats-tooltip">
                        ${t.correctCountLabel}: ${item.correctCount}<br>
                        ${t.wrongCountLabel}: ${item.wrongCount}<br>
                        ${t.streakCountLabel}: ${item.streakCount}
                    </div>
                    <span class="word-info-text">
                        ${item.word} - ${item.translation} (${t.proficiencyRateLabel} ${proficiencyRate}%)
                    </span>
                `;

                // ç²å–æŒ‰éˆ•å’Œ tooltip å…ƒç´ ï¼Œä»¥ä¾¿æ·»åŠ äº‹ä»¶ç›£è½å™¨å’Œå‹•æ…‹èª¿æ•´ä½ç½®
                const infoButton = infoSpan.querySelector('.info-button');
                const statsTooltip = infoSpan.querySelector('.stats-tooltip');

                // æ»‘é¼ ç§»å…¥äº‹ä»¶ï¼šé¡¯ç¤º tooltip ä¸¦å‹•æ…‹èª¿æ•´ä½ç½®
                infoButton.addEventListener('mouseover', function() {
                    statsTooltip.style.display = 'block'; // å…ˆé¡¯ç¤ºï¼Œä»¥ä¾¿è¨ˆç®—å°ºå¯¸
                    statsTooltip.style.opacity = '1';

                    const buttonRect = infoButton.getBoundingClientRect();
                    const tooltipRect = statsTooltip.getBoundingClientRect();
                    const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
                    const viewportHeight = window.innerHeight || document.documentElement.clientHeight;

                    // é è¨­ä½ç½® (åœ¨æŒ‰éˆ•å³å´ï¼Œèˆ‡æŒ‰éˆ•é ‚éƒ¨å°é½Š)
                    let left = buttonRect.width + 5; // è·æŒ‰éˆ•å³å´ 5px
                    let top = 0; // èˆ‡æŒ‰éˆ•é ‚éƒ¨å°é½Š (ç›¸å°æ–¼ infoButton çš„çˆ¶å®¹å™¨)

                    // æª¢æŸ¥æ˜¯å¦æº¢å‡ºå³å´
                    if (buttonRect.right + tooltipRect.width + 10 > viewportWidth) {
                        // å¦‚æœå³å´ç©ºé–“ä¸è¶³ï¼Œå˜—è©¦é¡¯ç¤ºåœ¨å·¦å´
                        left = -(tooltipRect.width + 5); // è·æŒ‰éˆ•å·¦å´ 5px
                    }

                    // æª¢æŸ¥æ˜¯å¦æº¢å‡ºåº•éƒ¨
                    if (buttonRect.top + tooltipRect.height + 10 > viewportHeight) {
                        // å¦‚æœåº•éƒ¨ç©ºé–“ä¸è¶³ï¼Œå˜—è©¦é¡¯ç¤ºåœ¨æŒ‰éˆ•ä¸Šæ–¹
                        top = -(tooltipRect.height + 5); // è·æŒ‰éˆ•é ‚éƒ¨ 5px
                    }

                    // æ‡‰ç”¨è¨ˆç®—å‡ºçš„ä½ç½® (é€™è£¡çš„ left å’Œ top æ˜¯ç›¸å°æ–¼ infoSpan çš„)
                    statsTooltip.style.left = `${left}px`;
                    statsTooltip.style.top = `${top}px`;
                });

                // æ»‘é¼ ç§»å‡ºäº‹ä»¶ï¼šéš±è— tooltip
                infoButton.addEventListener('mouseleave', function() {
                    statsTooltip.style.opacity = '0';
                    // å»¶é²éš±è—ï¼Œç¢ºä¿éæ¸¡æ•ˆæœå®Œæˆ
                    setTimeout(() => {
                        statsTooltip.style.display = 'none';
                    }, 200); // èˆ‡ CSS transition-duration ä¿æŒä¸€è‡´
                });

                div.appendChild(infoSpan); // å°‡ infoSpan æ·»åŠ åˆ° div

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'word-item-actions';

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = t.delete;
                deleteBtn.onclick = () => {
                    words.splice(index, 1);
                    renderWords();
                    markAsNeedsSave();
                };
                actionsDiv.appendChild(deleteBtn);

                div.appendChild(actionsDiv);
                wordList.appendChild(div);
            }); // <-- é€™å€‹æ˜¯ forEach å¾ªç’°çš„æ­£ç¢ºçµæŸæ¨™ç±¤
        }
    }

    // è¼”åŠ©å‡½æ•¸ï¼šæ›´æ–°æˆ–æ–°å¢å–®å­—ï¼ˆç”¨æ–¼æ‰¹é‡åŒ¯å…¥è‹±æ–‡,ä¸­æ–‡æ ¼å¼ï¼‰
    function updateOrCreateWord(newWordObj) {
        const existingIndex = words.findIndex(item => item.word === newWordObj.word);
        if (existingIndex !== -1) {
            words[existingIndex].translation = newWordObj.translation;
            // ***** ä¿®æ”¹é» 5: æ‰¹é‡åŒ¯å…¥æ™‚ï¼Œä¸æ¸…ç©ºé€£å‹æ•¸ï¼Œåƒ…æ›´æ–°ç¿»è­¯ *****
            words[existingIndex].streakCount = words[existingIndex].streakCount !== undefined ? words[existingIndex].streakCount : 0;
            return 'updated';
        } else {
            // å¦‚æœå–®å­—ä¸å­˜åœ¨ï¼Œæ–°å¢
            // ***** ä¿®æ”¹é» 5: æ‰¹é‡åŒ¯å…¥æ™‚ï¼Œæ–°å–®å­—é è¨­é€£å‹æ•¸ç‚º 0 *****
            words.push({ ...newWordObj, streakCount: 0 }); // ç¢ºä¿æ–°å–®å­—æœ‰ streakCount
            return 'added';
        }
    }

    // å°‡å–®å­—åŒ¯å…¥å’Œæ•¸æ“šå‚™ä»½é‚„åŸåŠŸèƒ½åˆä½µåˆ°ä¸€å€‹ textarea
    function bulkImportFromTextarea() {
        const t = translations[currentLanguage];
        const inputText = document.getElementById('dataTextarea').value.trim();
        if (!inputText) {
            alert(t.alertPasteWordsRequired);
            return;
        }

        try {
            const potentialJson = JSON.parse(inputText);
            if (potentialJson.words && Array.isArray(potentialJson.words)) {
                alert(t.alertUseImportAllData);
                return;
            }
        } catch (e) {
            // Not JSON data, proceed as bulk word
        }

        let addedCount = 0;
        let updatedCount = 0;

        const lines = inputText.split('\n');
        for (const line of lines) {
            const parts = line.split(',').map(s => s.trim());
            if (parts.length >= 2 && parts[0] && parts[1]) {
                const word = parts[0];
                const translation = parts[1];
                const newWordObj = { word, translation, wrongCount: 0, correctCount: 0, hasBeenTested: false, streakCount: 0 }; // ç¢ºä¿æ–°å»ºæ™‚æœ‰ streakCount
                const status = updateOrCreateWord(newWordObj);
                if (status === 'added') addedCount++;
                else updatedCount++;
            }
        }
        document.getElementById('dataTextarea').value = '';
        renderWords();
        if (addedCount > 0 || updatedCount > 0) {
            markAsNeedsSave();
            alert(`${t.alertBulkImportSummary} ${addedCount} ${t.alertBulkImportAdded}, ${updatedCount} ${t.alertBulkImportUpdated}.`);
        } else {
            alert(t.alertNoValidWordsImported);
        }
    }

    function saveWords() {
        localStorage.setItem('words', JSON.stringify(words));
    }

    function saveSettings() {
        const wordsPerRoundInput = document.getElementById('wordsPerRound');
        const newWordsPerRound = parseInt(wordsPerRoundInput.value);
        const newEnableWeightSystem = document.getElementById('enableWeightSystem').checked;
        const t = translations[currentLanguage];

        if (isNaN(newWordsPerRound) || newWordsPerRound < 1) {
            alert(t.alertInvalidNumber);
            wordsPerRoundInput.value = settings.wordsPerRound;
            return;
        }

        let settingsChanged = false;
        if (settings.wordsPerRound !== newWordsPerRound) {
            settings.wordsPerRound = newWordsPerRound;
            settingsChanged = true;
        }
        if (settings.enableWeightSystem !== newEnableWeightSystem) {
            settings.enableWeightSystem = newEnableWeightSystem;
            settingsChanged = true;
        }

        if (settingsChanged) {
            localStorage.setItem('wordGameSettings', JSON.stringify(settings));
            markAsNeedsSave();
        }
    }

    function clearAllWords() {
        const t = translations[currentLanguage];
        if (confirm(t.confirmDeleteAll)) {
            words = [];
            localStorage.removeItem('words');
            renderWords();
            markAsNeedsSave();
            console.log(t.alertDeleteAllDone);
        }
    }

    function resetAllWrongCounts() {
        const t = translations[currentLanguage];
        if (confirm(t.confirmResetWeights)) {
            words.forEach(item => {
                item.wrongCount = 0;
                item.correctCount = 0;
                item.hasBeenTested = false;
                item.streakCount = 0; // ***** ä¿®æ”¹é» 6: é‡è¨­æ¬Šé‡æ™‚æ¸…ç©ºé€£å‹æ•¸ *****
            });
            renderWords();
            markAsNeedsSave();
            console.log(t.alertWeightsReset);
        }
    }

    function saveAll() {
      if (!needsSave) {
        console.log(translations[currentLanguage].alertNoChangesToSave || "æ²’æœ‰è®Šæ›´éœ€è¦å„²å­˜ã€‚");
        return;
      }

      saveWords();
      saveSettings();

      originalWords = JSON.parse(JSON.stringify(words));
      originalSettings = JSON.parse(JSON.stringify(settings));

      needsSave = false;
      updateSaveButtonState();
      console.log(translations[currentLanguage].alertSaveDone);
    }

    // --- æ•¸æ“šåŒ¯å‡º/åŒ¯å…¥åŠŸèƒ½ (ç´”æ–‡å­—ç‰ˆ) ---

    function exportAllData() {
        const t = translations[currentLanguage];
        const data = {
            words: words,
            settings: settings
        };
        const jsonString = JSON.stringify(data);
        const dataTextarea = document.getElementById('dataTextarea');
        dataTextarea.value = jsonString;

        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(jsonString)
                .then(() => {
                    alert(t.alertDataCopied);
                    console.log(t.alertDataCopied);
                })
                .catch(err => {
                    console.error('Failed to copy data: ', err);
                    alert('è‡ªå‹•è¤‡è£½æ•¸æ“šå¤±æ•—ã€‚è«‹æ‰‹å‹•å¾æ–‡å­—å€åŸŸè¤‡è£½æ–‡æœ¬ã€‚');
                });
        } else {
            dataTextarea.select();
            try {
                document.execCommand('copy');
                alert(t.alertDataCopied);
                console.log(t.alertDataCopied);
            } catch (err) {
                console.warn('Unable to copy to clipboard. Please copy manually.');
                alert('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æŒè‡ªå‹•è¤‡è£½ã€‚è«‹é¸æ“‡æ–‡å­—å€åŸŸä¸­çš„æ–‡æœ¬ä¸¦æ‰‹å‹•è¤‡è£½ã€‚');
            }
        }
    }

    function importAllData() {
        const t = translations[currentLanguage];
        const inputText = document.getElementById('dataTextarea').value.trim();
        if (!inputText) {
            alert(t.alertPasteBackupRequired);
            return;
        }
        try {
            const importedData = JSON.parse(inputText);
            applyImportedData(importedData);
            alert(t.alertDataImported);
        } catch (e) {
            alert(t.alertInvalidData);
            console.error("Import error:", e);
        } finally {
            document.getElementById('dataTextarea').value = '';
        }
    }

    function applyImportedData(importedData) {
        let currentWordsMap = new Map();
        words.forEach(word => currentWordsMap.set(word.word, word));

        if (importedData.words && Array.isArray(importedData.words)) {
            importedData.words.forEach(importedWord => {
                const existingWord = currentWordsMap.get(importedWord.word);
                if (existingWord) {
                    existingWord.translation = importedWord.translation;
                    existingWord.wrongCount = importedWord.wrongCount !== undefined ? importedWord.wrongCount : 0;
                    existingWord.correctCount = importedWord.correctCount !== undefined ? importedWord.correctCount : 0;
                    existingWord.hasBeenTested = importedWord.hasBeenTested !== undefined ? importedWord.hasBeenTested : false;
                    // ***** ä¿®æ”¹é» 7: åŒ¯å…¥æ™‚ç¢ºä¿ streakCount å±¬æ€§è¢«è¤‡è£½æˆ–åˆå§‹åŒ– *****
                    existingWord.streakCount = importedWord.streakCount !== undefined ? importedWord.streakCount : 0;
                } else {
                    currentWordsMap.set(importedWord.word, {
                        word: importedWord.word,
                        translation: importedWord.translation,
                        wrongCount: importedWord.wrongCount !== undefined ? importedWord.wrongCount : 0,
                        correctCount: importedWord.correctCount !== undefined ? importedWord.correctCount : 0,
                        hasBeenTested: importedWord.hasBeenTested !== undefined ? importedWord.hasBeenTested : false,
                        // ***** ä¿®æ”¹é» 7: åŒ¯å…¥æ™‚ç¢ºä¿ streakCount å±¬æ€§è¢«è¤‡è£½æˆ–åˆå§‹åŒ– *****
                        streakCount: importedWord.streakCount !== undefined ? importedWord.streakCount : 0
                    });
                }
            });
            words = Array.from(currentWordsMap.values());
            localStorage.setItem('words', JSON.stringify(words));
        } else {
            console.warn("Imported data does not contain a valid 'words' array.");
        }

        if (importedData.settings && typeof importedData.settings === 'object') {
            settings = {
                wordsPerRound: importedData.settings.wordsPerRound !== undefined ? parseInt(importedData.settings.wordsPerRound) : 10,
                enableWeightSystem: importedData.settings.enableWeightSystem !== undefined ? Boolean(importedData.settings.enableWeightSystem) : true
            };
            localStorage.setItem('wordGameSettings', JSON.stringify(settings));
        } else {
            console.warn("Imported data does not contain valid 'settings' object.");
        }

        document.getElementById('wordsPerRound').value = settings.wordsPerRound;
        document.getElementById('enableWeightSystem').checked = settings.enableWeightSystem;
        renderWords();
        originalWords = JSON.parse(JSON.stringify(words));
        originalSettings = JSON.parse(JSON.stringify(settings));
        needsSave = false;
        updateSaveButtonState();
    }


    const translations = {
        zh: {
            title: 'å–®å­—ç®¡ç†å¾Œå°',
            bulkAndBackupTitle: 'å–®å­—åŒ¯å…¥ / æ•¸æ“šå‚™ä»½èˆ‡é‚„åŸ',
            bulkTextareaPlaceholder: 'è«‹åœ¨æ­¤è¼¸å…¥ã€Œå–®å­—,æ„æ€æˆ–ç¿»è­¯ã€æ ¼å¼å–®å­—ï¼ˆæ¯è¡Œä¸€çµ„ï¼‰ï¼Œæˆ–è²¼ä¸Šå‚™ä»½æ•¸æ“š...',
            bulkImportBtn: 'æ‰¹é‡åŒ¯å…¥å–®å­—ï¼ˆæ›´æ–°æˆ–æ–°å¢ï¼‰',
            exportDataBtn: 'åŒ¯å‡ºæ‰€æœ‰æ•¸æ“šï¼ˆè¤‡è£½è²¼ä¸Šï¼‰',
            importDataBtn: 'åŒ¯å…¥æ‰€æœ‰æ•¸æ“šï¼ˆè¦†è“‹èˆ‡åˆä½µï¼‰',

            save: 'ğŸ’¾å„²å­˜æ‰€æœ‰è¨­å®š',
            clear: 'âŒä¸€éµåˆªé™¤æ‰€æœ‰å–®å­—',
            gameSettingsTitle: 'éŠæˆ²è¨­å®š',
            wordsPerRoundLabel: 'æ¯å±€å–®å­—æ•¸é‡ï¼š',
            enableWeightSystemText: 'å•Ÿç”¨æ¬Šé‡å‡ºé¡Œç³»çµ± (å„ªå…ˆè€ƒéŒ¯çš„å­—)',
            resetAllWrongCountsText: 'ğŸ“Š é‡è¨­æ‰€æœ‰å–®å­—æ¬Šé‡',
            wordListSectionTitle: 'å–®å­—åˆ—',
            delete: 'åˆªé™¤',
            reminder: 'ğŸ”” æ‚¨æœ‰æœªå„²å­˜çš„è®Šæ›´ï¼è«‹é»æ“Šã€ğŸ’¾å„²å­˜æ‰€æœ‰è¨­å®šã€‘',
            alertPasteWordsRequired: 'è«‹åœ¨æ–‡å­—å€åŸŸè¼¸å…¥æˆ–è²¼ä¸Šå–®å­—ï¼',
            alertUseImportAllData: 'åµæ¸¬åˆ°å¯èƒ½æ˜¯å®Œæ•´çš„å‚™ä»½æ•¸æ“šã€‚è«‹é»æ“Šã€ŒåŒ¯å…¥æ‰€æœ‰æ•¸æ“šã€æŒ‰éˆ•ã€‚',
            alertBulkImportSummary: 'æ‰¹é‡åŒ¯å…¥å®Œæˆï¼',
            alertBulkImportAdded: 'æ–°å¢',
            alertBulkImportUpdated: 'æ›´æ–°',
            alertNoValidWordsImported: 'æ²’æœ‰æœ‰æ•ˆå–®å­—è¢«åŒ¯å…¥æˆ–æ›´æ–°ã€‚',
            alertSaveDone: 'å„²å­˜æˆåŠŸï¼',
            confirmDeleteAll: 'ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰å–®å­—å—ï¼Ÿé€™å€‹å‹•ä½œç„¡æ³•å¾©åŸï¼',
            alertDeleteAllDone: 'å·²æ¸…ç©ºæ‰€æœ‰å–®å­—ï¼',
            alertInvalidNumber: 'è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å­—ï¼',
            alertNoChangesToSave: 'æ²’æœ‰è®Šæ›´éœ€è¦å„²å­˜ã€‚',
            confirmResetWeights: 'ç¢ºå®šè¦é‡è¨­æ‰€æœ‰å–®å­—çš„éŒ¯èª¤æ¬¡æ•¸ï¼ˆæ¬Šé‡ï¼‰å—ï¼Ÿæ­¤å‹•ä½œç„¡æ³•å¾©åŸï¼',
            alertWeightsReset: 'æ‰€æœ‰å–®å­—çš„æ¬Šé‡å·²é‡è¨­ã€‚',
            accuracyRateLabel: 'ç­”å°ç‡:', // é€™å€‹æ¨™ç±¤å¯èƒ½ä¸å†ä½¿ç”¨ï¼Œä½†æš«æ™‚ä¿ç•™
            alertDataCopied: 'æ•¸æ“šå·²è¤‡è£½åˆ°å‰ªè²¼æ¿ï¼',
            alertPasteBackupRequired: 'è«‹åœ¨æ–‡å­—å€åŸŸè²¼ä¸Šå‚™ä»½æ•¸æ“šï¼',
            alertInvalidData: 'ç„¡æ•ˆçš„æ•¸æ“šæ ¼å¼ï¼è«‹æª¢æŸ¥æ‚¨è²¼ä¸Šçš„å…§å®¹æ˜¯å¦ç‚ºæ­£ç¢ºçš„ JSON æ ¼å¼ã€‚',
            alertDataImported: 'æ•¸æ“šåŒ¯å…¥æˆåŠŸï¼',
            noWordsInBank: 'ç›®å‰å–®å­—åº«ä¸­æ²’æœ‰å–®å­—ã€‚',
            promptToAddWordsInBankDynamic: 'è«‹ä½¿ç”¨ä¸Šæ–¹ã€Œ{0}ã€åŠŸèƒ½æ–°å¢å–®å­—ã€‚',
            sortOrderLabel: 'æ’åºæ–¹å¼:',
            sortAlphabeticalAscOption: 'å­—æ¯é †åº (A-Z)',
            sortAlphabeticalDescOption: 'å­—æ¯é †åº (Z-A)',
            sortAccuracyDescOption: 'ç†Ÿç·´åº¦ (é«˜åˆ°ä½)', // ***** ä¿®æ”¹é» 8: æ›´æ–°æ’åºé¸é …çš„ç¿»è­¯ *****
            sortAccuracyAscOption: 'ç†Ÿç·´åº¦ (ä½åˆ°é«˜)', // ***** ä¿®æ”¹é» 8: æ›´æ–°æ’åºé¸é …çš„ç¿»è­¯ *****
            proficiencyRateLabel: 'ç†Ÿç·´åº¦:',
            correctCountLabel: 'ç­”å°æ¬¡æ•¸',
            wrongCountLabel: 'ç­”éŒ¯æ¬¡æ•¸',
            streakCountLabel: 'ç•¶å‰é€£å‹',
        },
        en: {
            title: 'Word Management',
            bulkAndBackupTitle: 'Word Import / Data Backup & Restore',
            bulkTextareaPlaceholder: 'Enter "English,Meaning or Translation" format words here (one per line), or paste backup data...',
            bulkImportBtn: 'Bulk Import Words (Update or Add)',
            exportDataBtn: 'Export All Data (Copy/Paste)',
            importDataBtn: 'Import All Data (Overwrite & Merge)',

            save: 'ğŸ’¾ Save All Settings',
            clear: 'âŒ Delete All Words',
            gameSettingsTitle: 'Game Settings',
            wordsPerRoundLabel: 'Words per round:',
            enableWeightSystemText: 'Enable Weighted Question System (Prioritize incorrect words)',
            resetAllWrongCountsText: 'ğŸ“Š Reset All Word Weights',
            wordListSectionTitle: 'Current Words',
            delete: 'Delete',
            reminder: 'ğŸ”” You have unsaved changes! Click ã€ğŸ’¾ Save All Settingsã€‘',
            alertPasteWordsRequired: 'Please enter or paste words into the text area!',
            alertUseImportAllData: 'Detected a complete backup data. Please click "Import All Data" button.',
            alertBulkImportSummary: 'Bulk import complete!',
            alertBulkImportAdded: 'added',
            alertBulkImportUpdated: 'updated',
            alertNoValidWordsImported: 'No valid words were imported or updated.',
            alertSaveDone: 'Saved successfully!',
            confirmDeleteAll: 'Are you sure you want to delete all words? This cannot be undone!',
            alertDeleteAllDone: 'All words have been cleared!',
            alertInvalidNumber: 'Please enter a valid number!',
            alertNoChangesToSave: 'No changes to save.',
            confirmResetWeights: 'Are you sure you want to reset all word error counts (weights)? This action cannot be undone!',
            alertWeightsReset: 'All word weights have been reset.',
            accuracyRateLabel: 'Accuracy Rate:',
            alertDataCopied: 'Data copied to clipboard!',
            alertPasteBackupRequired: 'Please paste backup data into the text area!',
            alertInvalidData: 'Invalid data format! Please check if the content you pasted is in correct JSON format.',
            alertDataImported: 'Data imported successfully!',
            noWordsInBank: 'No words currently in the word bank.',
            promptToAddWordsInBankDynamic: 'Please use the "{0}" function above to add words.',
            sortOrderLabel: 'Sort by:',
            sortAlphabeticalAscOption: 'Alphabetical (A-Z)',
            sortAlphabeticalDescOption: 'Alphabetical (Z-A)',
            sortAccuracyDescOption: 'Proficiency (High to Low)', // ***** ä¿®æ”¹é» 8: æ›´æ–°æ’åºé¸é …çš„ç¿»è­¯ *****
            sortAccuracyAscOption: 'Proficiency (Low to High)', // ***** ä¿®æ”¹é» 8: æ›´æ–°æ’åºé¸é …çš„ç¿»è­¯ *****
            proficiencyRateLabel: 'Proficiency:',
            correctCountLabel: 'Correct',
            wrongCountLabel: 'Wrong',
            streakCountLabel: 'Current Streak',
        }
    };

    function toggleLanguage() {
        currentLanguage = currentLanguage === 'zh' ? 'en' : 'zh';
        updateLanguage();
    }

    function updateLanguage() {
        const t = translations[currentLanguage];

        document.title = t.title;
        document.getElementById('mainTitle').textContent = t.title;
        document.getElementById('bulkAndBackupTitle').textContent = t.bulkAndBackupTitle;
        document.getElementById('dataTextarea').placeholder = t.bulkTextareaPlaceholder;
        document.getElementById('bulkImportBtn').textContent = t.bulkImportBtn;
        document.getElementById('exportDataBtn').textContent = t.exportDataBtn;
        document.getElementById('importDataBtn').textContent = t.importDataBtn;

        document.getElementById('gameSettingsTitle').textContent = t.gameSettingsTitle;

        const wordsPerRoundLabel = document.getElementById('wordsPerRoundLabel');
        if (wordsPerRoundLabel) {
            wordsPerRoundLabel.textContent = t.wordsPerRoundLabel;
        }

        const enableWeightSystemLabel = document.getElementById('enableWeightSystemLabel');
        if (enableWeightSystemLabel) {
            enableWeightSystemLabel.textContent = t.enableWeightSystemText;
        }

        const resetWeightsButtonText = document.getElementById('resetWeightsButtonText');
        if (resetWeightsButtonText) {
            resetWeightsButtonText.textContent = t.resetAllWrongCountsText;
        }

        document.getElementById('wordListSectionTitle').textContent = t.wordListSectionTitle;

        document.getElementById('sortOrderLabel').textContent = t.sortOrderLabel;
        document.getElementById('sortAlphabeticalAscOption').textContent = t.sortAlphabeticalAscOption;
        document.getElementById('sortAlphabeticalDescOption').textContent = t.sortAlphabeticalDescOption;
        document.getElementById('sortAccuracyDescOption').textContent = t.sortAccuracyDescOption;
        document.getElementById('sortAccuracyAscOption').textContent = t.sortAccuracyAscOption;

        document.getElementById('saveAllButton').textContent = t.save;
        document.getElementById('clearAllWordsButton').textContent = t.clear;

        document.getElementById('langToggleBtn').textContent = 'ğŸŒ ' + (currentLanguage === 'zh' ? 'English' : 'ä¸­æ–‡');

        renderWords();
        updateSaveButtonState();
    }

    // ***** ä¿®æ”¹é» 9: å¾ä¸»éŠæˆ²é é¢æ¥æ”¶è¨Šæ¯ä»¥æ›´æ–°èªè¨€å’Œæ¨¡å¼ *****
    window.addEventListener('message', function(event) {
        if (event.data.type === 'languageChange') {
            currentLanguage = event.data.lang;
            updateLanguage();
        }
        if (event.data.type === 'darkModeChange') {
            if (event.data.isDark) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('wordsPerRound').value = settings.wordsPerRound;
        document.getElementById('enableWeightSystem').checked = settings.enableWeightSystem;

        originalWords = JSON.parse(JSON.stringify(words));
        originalSettings = JSON.parse(JSON.stringify(settings));

        document.getElementById('dataTextarea').addEventListener('input', markAsNeedsSave);
        document.getElementById('wordsPerRound').addEventListener('input', markAsNeedsSave);
        document.getElementById('enableWeightSystem').addEventListener('change', markAsNeedsSave);

        needsSave = false;
        updateLanguage();

        document.getElementById('sortOrder').value = 'alphabetical_asc';
        renderWords();
    });
</script>
</body>
</html>