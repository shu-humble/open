<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Geometry Text Book</title>
<style>
html, body {
    margin: 0;
    padding: 0;
    font-family: "Noto Serif TC", "Source Han Serif TC", "Georgia", serif;
}
body {
    padding: 16px;
    box-sizing: border-box;
    background: radial-gradient(1200px 800px at 10% 0%, #f5f1e7 0%, #f8f6f0 45%, #eef2f4 100%);
    color: #1b1b1b;
}
.header {
    flex-shrink: 0;
    margin-bottom: 10px;
}
.header b {
    letter-spacing: 0.5px;
}
.main-content-wrapper {
    display: flex;
    min-height: 0;
    background: #fdfdfb;
    border: 1px solid #e4e0d6;
    border-radius: 16px;
    box-shadow: 0 10px 25px rgba(33, 33, 33, 0.08);
    overflow: visible;
}
.left {
    flex: 0 0 24%;
    max-width: 340px;
    min-width: 220px;
    padding-right: 12px;
    border-right: 1px solid #e7e1d4;
    overflow-y: auto;
    background: linear-gradient(180deg, #fbfaf6 0%, #f6f2ea 100%);
}
.right {
    flex: 1;
    padding-left: 20px;
    display: flex;
    flex-direction: column;
    min-height: 0;
    background: #fcfcfa;
}
.chapter-link {
    display: block;
    margin-bottom: 4px;
    text-decoration: none;
    color: #2f5d62;
    font-size: 0.98em;
    line-height: 1.3;
    padding: 2px 0;
}
.chapter-link:hover {
    color: #1f3f43;
    text-decoration: underline;
}
.chapter-link.active {
    color: #0e2b2d;
    font-weight: bold;
    text-decoration: underline;
}
.left br { display: none; }
.fs-btn {
    padding: 6px 10px;
    font-size: 13px;
    cursor: pointer;
    background: #2f5d62;
    color: #f7f4ed;
    border: 1px solid #264b4f;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
}
.page-input {
    width: 68px;
    padding: 6px;
    font-size: 13px;
    border-radius: 8px;
    border: 1px solid #d7d0c2;
    background: #fffdf8;
}
#pdf-container {
    display: block;
}
#pdf-container > #pdf-viewer { flex: 0; }
.pdf-toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 0;
    flex-wrap: nowrap;
    justify-content: center;
    background: linear-gradient(90deg, #f6efe2 0%, #f2f7f6 100%);
    border: 1px solid #e7e1d4;
    border-radius: 12px;
    overflow-x: auto;
}
#pdf-viewer {
    width: 100%;
    flex-grow: 0;
    overflow: visible;
    background: transparent;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 0;
    position: relative;
}
#pdf-canvas {
    width: auto;
    height: auto;
    max-width: 100%;
    background: #fff;
    display: block;
    margin: 0 auto;
    box-shadow: 0 12px 30px rgba(20, 20, 20, 0.15);
}
#pdf-page {
    position: relative;
    margin: 0 auto;
    display: inline-block;
    width: max-content;
    height: max-content;
    max-width: 100%;
}
#pdf-text-layer {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: auto;
}
.textLayer {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    color: transparent;
    pointer-events: auto;
}
.textLayer span { color: transparent; }
.textLayer ::selection { background: rgba(0, 0, 255, 0.2); }
.mobile-controls {
    display: none;
    gap: 8px;
    align-items: center;
    margin: 8px 0;
    background: #f7f2e8;
    border: 1px solid #e7e1d4;
    border-radius: 12px;
    padding: 8px;
    flex-wrap: nowrap;
}
.mobile-controls select { flex: 0 0 auto; padding: 8px; font-size: 14px; }
.mobile-controls input { padding: 8px; font-size: 14px; }
.mobile-controls button { padding: 8px 10px; font-size: 14px; }
.mobile-controls .mobile-nav { display: flex; gap: 8px; }
@media (max-width: 768px) {
  .main-content-wrapper { flex-direction: column; }
  .left { display: none; }
  .mobile-controls { display: flex; flex-wrap: nowrap; overflow-x: auto; }
  #pdf-viewer { min-height: 0; overflow: visible; }
  .right { padding-left: 0; }
  .pdf-toolbar { display: none; }
  #mobile-open-tab,
  #mode-select-mobile, #zoom-out-mobile, #zoom-reset-mobile, #zoom-in-mobile { display: none; }
  .mobile-controls { position: static; }
  .mobile-controls > * { width: auto; }
  body { padding: 12px; }
  .header { margin-bottom: 6px; }
}
body.mobile-focus .header,
body.mobile-focus .mobile-controls,
body.mobile-focus .sources {
  display: none;
}
body.desktop-focus .header,
body.desktop-focus .left,
body.desktop-focus .sources {
  display: none;
}
body.desktop-focus .main-content-wrapper {
  border: none;
  box-shadow: none;
}
.focus-exit-fab {
  position: fixed;
  right: 16px;
  bottom: 16px;
  z-index: 9999;
  display: none;
}
body.mobile-focus .focus-exit-fab,
body.desktop-focus .focus-exit-fab {
  display: inline-flex;
}
</style>
</head><body>
<div class="header">
    <b><font size="8"> Text Book</font></b><br>
    <hr>
</div>

<div class="mobile-controls">
    <select id="chapter-select" aria-label="Choose chapter"></select>
    <div class="mobile-nav">
      <input id="page-input" class="page-input" type="number" min="1" placeholder="Page">
    </div>
    <button id="mobile-focus-toggle" class="fs-btn" title="Focus">Focus</button>
    <button id="mobile-open-tab" class="fs-btn">New Tab</button>
    <button id="zoom-out-mobile" class="fs-btn" title="Zoom out">A-</button>
    <button id="zoom-reset-mobile" class="fs-btn" title="Reset zoom">A</button>
    <button id="zoom-in-mobile" class="fs-btn" title="Zoom in">A+</button>

</div>

<div class="main-content-wrapper">
    <div class="left">
        <font size="5">
        <a href="open/幾何課本/2nd Semester Assignments 2025-2026.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Assignment Sheet')">Assignment Sheet</a><br>
        <a href="open/幾何課本/Geometry-01.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 01')">Chapter 01</a><br>
        <a href="open/幾何課本/Geometry-02.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 02')">Chapter 02</a><br>
        <a href="open/幾何課本/Geometry-03.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 03')">Chapter 03</a><br>
        <a href="open/幾何課本/Geometry-04.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 04')">Chapter 04</a><br>
        <a href="open/幾何課本/Geometry-05.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 05')">Chapter 05</a><br>
        <a href="open/幾何課本/Geometry-06.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 06')">Chapter 06</a><br>
        <a href="open/幾何課本/Geometry-07.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 07')">Chapter 07</a><br>
        <a href="open/幾何課本/Geometry-08.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 08')">Chapter 08</a><br>
        <a href="open/幾何課本/Geometry-09.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 09')">Chapter 09</a><br>
        <a href="open/幾何課本/Geometry-10.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 10')">Chapter 10</a><br>
        <a href="open/幾何課本/Geometry-11.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 11')">Chapter 11</a><br>
        <a href="open/幾何課本/Geometry-12.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 12')">Chapter 12</a><br>
        <a href="open/幾何課本/Geometry-13.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 13')">Chapter 13</a><br>
        <a href="open/幾何課本/Geometry-14.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 14')">Chapter 14</a><br>
        <a href="open/幾何課本/Geometry-15.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 15')">Chapter 15</a><br>
        <a href="open/幾何課本/Geometry-16.pdf" class="chapter-link" onclick="loadPDF(event, this.href, 'Chapter 16')">Chapter 16</a><br>
        </font>
    </div>

    <div class="right">
     <!--  <h3 id="pdf-title"></h3> -->
        <div id="pdf-container">
            <div class="pdf-toolbar">
              <input id="page-input-main" class="page-input" type="number" min="1" placeholder="Page">
                <button id="prev-page" class="fs-btn">Prev</button>
                <button id="next-page" class="fs-btn">Next</button>
                <button id="zoom-out" class="fs-btn" title="Zoom out">A-</button>
                <button id="zoom-reset" class="fs-btn" title="Reset zoom">A</button>
                <button id="zoom-in" class="fs-btn" title="Zoom in">A+</button>
                <button id="desktop-focus-toggle" class="fs-btn">Focus</button>
                <button id="desktop-focus-exit" class="fs-btn" style="display:none;">Exit</button>
                <button id="open-tab-main" class="fs-btn">New Tab</button>

            </div>
                        <div id="pdf-viewer" aria-label="PDF viewer">
                <div id="pdf-page">
                    <canvas id="pdf-canvas"></canvas>
                    <div id="pdf-text-layer" class="textLayer"></div>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="sources">
  Sources: <a href="https://sites.google.com/a/lasdk8.org/mr-pasturel/geometry-for-enjoyment-and-challenge">Geometry for Enjoyment and Challenge</a>
</div>
<button id="focus-exit-fab" class="fs-btn focus-exit-fab">Exit Focus</button>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
  if (window.pdfjsLib) {
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  }
</script>
<script>
(function() {
  const STORAGE_KEY = 'geometry:lastState';
  const TOTALS_VERSION = 2;
  let pdfDoc = null;
  let currentPdf = '';
  let currentPage = 1;
  let rendering = false;
  let pendingPage = null;
  let totals = null;
  let totalsPromise = null;
  let zoomLevel = 1;

  function loadState() {
    try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch (_) { return {}; }
  }
  function saveState(state) {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch (_) { /* ignore */ }
  }
  function getMode() {
    return 'book';
  }
  function updateModeUI() {
    if (pageInputMain) pageInputMain.placeholder = 'Book Page';
    if (pageInputMobile) pageInputMobile.placeholder = 'Book Page';
  }
  function normalizePath(inputHref) {
    try {
      const linkUrl = new URL(inputHref, window.location.href);
      const baseUrl = new URL('.', window.location.href);
      let p = decodeURIComponent(linkUrl.pathname);
      const basePath = decodeURIComponent(baseUrl.pathname);
      p = p.replace(/\/\s+open\//g, '/');
      const dupPrefix = basePath + 'open/';
      if (p.startsWith(dupPrefix)) p = basePath + p.slice(dupPrefix.length);
      if (p.startsWith(basePath)) return p.slice(basePath.length);
      return linkUrl.href;
    } catch (_) {
      return inputHref;
    }
  }
  function normalizeForActions(href) {
    try {
      const linkUrl = new URL(href, window.location.href);
      const baseUrl = new URL('.', window.location.href);
      let p = decodeURIComponent(linkUrl.pathname);
      const basePath = decodeURIComponent(baseUrl.pathname);
      p = p.replace(/\/[\s]*open\//g, '/');
      const dupPrefix = basePath + 'open/';
      if (p.startsWith(dupPrefix)) p = basePath + p.slice(dupPrefix.length);
      return p.startsWith(basePath) ? p.slice(basePath.length) : linkUrl.href;
    } catch (_) { return href; }
  }
  function isAssignmentLink(a) {
    if (!a) return false;
    const text = (a.textContent || '').toLowerCase();
    const href = (a.getAttribute('href') || a.href || '').toLowerCase();
    return text.indexOf('assignment') !== -1 || href.indexOf('assignments') !== -1;
  }
  function isAssignmentHref(href) {
    const raw = (href || '').toLowerCase();
    return raw.indexOf('assignment') !== -1 || raw.indexOf('assignments') !== -1;
  }
  function getOffsetForPdf(href) {
    const norm = normalizePath(href || '');
    return norm.indexOf('Geometry-01.pdf') !== -1 ? -1 : 0;
  }
  function getMinLogical(href) {
    const offset = getOffsetForPdf(href);
    return offset < 0 ? 1 - offset : 1;
  }
  function toPdfPage(href, logicalPage) {
    return logicalPage + getOffsetForPdf(href);
  }
  function toLogicalPage(href, pdfPage) {
    return pdfPage - getOffsetForPdf(href);
  }
  function getAllChapterLinks() {
    return Array.prototype.slice.call(document.querySelectorAll('.chapter-link'));
  }
  function getBookList() {
    return getAllChapterLinks().filter(function(a) {
      return !isAssignmentLink(a);
    }).map(function(a) {
      const raw = a.getAttribute('href') || a.href;
      return normalizePath(raw || '');
    }).filter(Boolean);
  }
  function readTotalsFromState(list) {
    const state = loadState();
    const cached = state.totals;
    if (!cached || cached.version !== TOTALS_VERSION) return null;
    if (!cached.list || !cached.pages || !cached.total) return null;
    if (cached.list.length !== list.length) return null;
    for (let i = 0; i < list.length; i++) {
      if (cached.list[i] !== list[i]) return null;
    }
    return cached;
  }
  function saveTotalsToState(list, pages, total) {
    const state = loadState();
    state.totals = { version: TOTALS_VERSION, list: list, pages: pages, total: total };
    saveState(state);
  }
  function getLastBookPage() {
    const state = loadState();
    return state.lastBookPage || null;
  }
  function setLastBookPage(value) {
    const state = loadState();
    const safe = Math.max(1, parseInt(value, 10) || 1);
    state.lastBookPage = safe;
    saveState(state);
  }
  function ensureTotals() {
    if (totals) return Promise.resolve(totals);
    if (totalsPromise) return totalsPromise;
    const list = getBookList();
    const cached = readTotalsFromState(list);
    if (cached) {
      totals = cached;
      return Promise.resolve(totals);
    }
    if (!window.pdfjsLib) return Promise.resolve(null);
    totalsPromise = (async function() {
      const pages = {};
      let total = 0;
      for (let i = 0; i < list.length; i++) {
        const href = list[i];
        try {
          const doc = await pdfjsLib.getDocument(href).promise;
          const rawPages = doc.numPages || 0;
          const offset = getOffsetForPdf(href);
          pages[href] = Math.max(0, rawPages - offset);
          total += pages[href];
          if (doc.destroy) await doc.destroy();
        } catch (_) {
          pages[href] = 0;
        }
      }
      totals = { list: list, pages: pages, total: total };
      saveTotalsToState(list, pages, total);
      totalsPromise = null;
      return totals;
    })();
    return totalsPromise;
  }
  function getGlobalPage() {
    if (!totals || !currentPdf) return null;
    let acc = 0;
    for (let i = 0; i < totals.list.length; i++) {
      const href = totals.list[i];
      const count = totals.pages[href] || 0;
      if (href === currentPdf) {
        const logical = Math.max(getMinLogical(currentPdf), toLogicalPage(currentPdf, currentPage));
        return acc + logical;
      }
      acc += count;
    }
    return null;
  }
  function findByGlobalPage(globalPage) {
    if (!totals) return null;
    let acc = 0;
    for (let i = 0; i < totals.list.length; i++) {
      const href = totals.list[i];
      const count = totals.pages[href] || 0;
      if (globalPage <= acc + count) {
        const page = globalPage - acc;
        if (page < getMinLogical(href)) return null;
        return { href: href, page: page };
      }
      acc += count;
    }
    return null;
  }

  const viewer = document.getElementById('pdf-viewer');
  const canvas = document.getElementById('pdf-canvas');
  const textLayer = document.getElementById('pdf-text-layer');
  const pageWrap = document.getElementById('pdf-page');
  const ctx = canvas ? canvas.getContext('2d') : null;
  const pageInputMain = document.getElementById('page-input-main');
  const pageInputMobile = document.getElementById('page-input');
  const zoomOutBtn = document.getElementById('zoom-out');
  const zoomInBtn = document.getElementById('zoom-in');
  const zoomResetBtn = document.getElementById('zoom-reset');
  const zoomOutMobile = document.getElementById('zoom-out-mobile');
  const zoomInMobile = document.getElementById('zoom-in-mobile');
  const zoomResetMobile = document.getElementById('zoom-reset-mobile');

  function setPageInputs() {
    const mode = getMode();
    if (mode === 'book' && totals && totals.total) {
      const isAssignment = isAssignmentHref(currentPdf);
      const stored = getLastBookPage();
      const globalPage = (isAssignment ? stored : getGlobalPage()) || stored || 1;
      if (pageInputMain) {
        if (!(isAssignment && !stored)) pageInputMain.value = globalPage;
        pageInputMain.max = totals.total;
        pageInputMain.min = 1;
      }
      if (pageInputMobile) {
        if (!(isAssignment && !stored)) pageInputMobile.value = globalPage;
        pageInputMobile.max = totals.total;
        pageInputMobile.min = 1;
      }
      return;
    }
    if (mode === 'book') {
      const globalPage = getLastBookPage() || 1;
      if (pageInputMain) {
        pageInputMain.value = globalPage;
        pageInputMain.max = '';
        pageInputMain.min = 1;
      }
      if (pageInputMobile) {
        pageInputMobile.value = globalPage;
        pageInputMobile.max = '';
        pageInputMobile.min = 1;
      }
      return;
    }
    const offset = getOffsetForPdf(currentPdf);
    const logical = Math.max(1, currentPage - offset);
    const maxLogical = pdfDoc ? Math.max(1, pdfDoc.numPages - offset) : '';
    if (pageInputMain) {
      pageInputMain.value = logical;
      pageInputMain.max = maxLogical;
      pageInputMain.min = getMinLogical(currentPdf);
    }
    if (pageInputMobile) {
      pageInputMobile.value = logical;
      pageInputMobile.max = maxLogical;
      pageInputMobile.min = getMinLogical(currentPdf);
    }
  }
  function storePage() {
    if (!currentPdf || !pdfDoc) return;
    const offset = getOffsetForPdf(currentPdf);
    const logical = Math.max(1, currentPage - offset);
    const state = loadState();
    state.lastPdf = currentPdf;
    state.pages = state.pages || {};
    state.pages[currentPdf] = logical;
    saveState(state);
    if (getMode() === 'book' && !isAssignmentHref(currentPdf)) {
      const globalPage = getGlobalPage();
      if (globalPage) setLastBookPage(globalPage);
    }
  }
  function renderPage(num) {
    if (!pdfDoc || !canvas || !ctx) return;
    rendering = true;
    pdfDoc.getPage(num).then(function(page) {
      const scale = zoomLevel;
      const scaled = page.getViewport({ scale: scale });
      canvas.height = scaled.height;
      canvas.width = scaled.width;
      if (pageWrap) {
        pageWrap.style.width = scaled.width + 'px';
        pageWrap.style.height = scaled.height + 'px';
      }
      const renderTask = page.render({ canvasContext: ctx, viewport: scaled });
      let textTask = Promise.resolve();
      if (textLayer && pdfjsLib.renderTextLayer) {
        textLayer.innerHTML = '';
        textLayer.style.width = scaled.width + 'px';
        textLayer.style.height = scaled.height + 'px';
        textTask = page.getTextContent().then(function(textContent) {
          return pdfjsLib.renderTextLayer({
            textContent: textContent,
            container: textLayer,
            viewport: scaled,
            textDivs: []
          }).promise;
        });
      }
      return Promise.all([renderTask.promise, textTask]);
    }).then(function() {
      rendering = false;
      setPageInputs();
      storePage();
      if (pendingPage !== null) {
        const next = pendingPage;
        pendingPage = null;
        renderPage(next);
      }
    }).catch(function(err) {
      rendering = false;
      console.error('PDF render error', err);
    });
  }
  function queueRender(num) {
    if (rendering) { pendingPage = num; return; }
    renderPage(num);
  }
  function changePage(num) {
    if (!pdfDoc) return;
    if (num < 1 || num > pdfDoc.numPages) return;
    currentPage = num;
    queueRender(num);
  }
  function jumpToGlobalPage(page) {
    if (!page || page < 1) return;
    ensureTotals().then(function(t) {
      if (!t || !t.total) return;
      if (page > t.total) return;
      const target = findByGlobalPage(page);
      if (!target) return;
      openPdf(target.href, target.page);
    });
  }
  function handleJump(page) {
    if (getMode() === 'book') {
      jumpToGlobalPage(page);
      return;
    }
    if (page < getMinLogical(currentPdf)) return;
    const target = toPdfPage(currentPdf, page);
    changePage(target);
  }
  function openPdf(url, targetPage, usePhysical) {
    if (!window.pdfjsLib) {
      if (viewer) viewer.textContent = 'PDF.js failed to load.';
      return;
    }
    const normalized = normalizePath(url);
    currentPdf = normalized;
    setActiveLink(normalized);
    const state = loadState();
    state.lastPdf = normalized;
    saveState(state);
    pdfjsLib.getDocument(normalized).promise.then(function(doc) {
      pdfDoc = doc;
      const savedPage = state.pages && parseInt(state.pages[normalized], 10);
      const offset = getOffsetForPdf(normalized);
      const minLogical = getMinLogical(normalized);
      if (usePhysical && targetPage && targetPage >= 1) {
        currentPage = targetPage;
      } else if (targetPage && targetPage >= minLogical) {
        currentPage = toPdfPage(normalized, targetPage);
      } else {
      const logical = savedPage && savedPage >= 1 ? savedPage : 1;
      currentPage = toPdfPage(normalized, logical);
    }
    const minPage = 1;
    if (currentPage < minPage) currentPage = minPage;
    if (currentPage > pdfDoc.numPages) currentPage = minPage;
    setPageInputs();
    renderPage(currentPage);
    }).catch(function(err) {
      console.error('PDF load error', err);
      if (viewer) viewer.textContent = 'Failed to load PDF.';
    });
  }

  window.loadPDF = function(event, pdfPath) {
    if (event && typeof event.preventDefault === 'function') event.preventDefault();
    openPdf(pdfPath);
  };

  function clampZoom(value) {
    return Math.min(2.5, Math.max(0.6, value));
  }
  function setZoom(value) {
    zoomLevel = clampZoom(value);
    renderPage(currentPage);
  }
  function bindNav() {
    const prevBtn = document.getElementById('prev-page');
    const nextBtn = document.getElementById('next-page');
    const fsMobile = document.getElementById('mobile-focus-toggle');
    const focusExitFab = document.getElementById('focus-exit-fab');
    const openTabMain = document.getElementById('open-tab-main');
    const focusBtn = document.getElementById('desktop-focus-toggle');
    const focusExitBtn = document.getElementById('desktop-focus-exit');
    if (prevBtn) prevBtn.addEventListener('click', function() { changePage(currentPage - 1); });
    if (nextBtn) nextBtn.addEventListener('click', function() { changePage(currentPage + 1); });
    if (zoomOutBtn) zoomOutBtn.addEventListener('click', function() { setZoom(zoomLevel - 0.1); });
    if (zoomInBtn) zoomInBtn.addEventListener('click', function() { setZoom(zoomLevel + 0.1); });
    if (zoomResetBtn) zoomResetBtn.addEventListener('click', function() { setZoom(1); });
    if (zoomOutMobile) zoomOutMobile.addEventListener('click', function() { setZoom(zoomLevel - 0.1); });
    if (zoomInMobile) zoomInMobile.addEventListener('click', function() { setZoom(zoomLevel + 0.1); });
    if (zoomResetMobile) zoomResetMobile.addEventListener('click', function() { setZoom(1); });
    if (pageInputMain) {
      pageInputMain.addEventListener('keydown', function(e) {
        if (e.key !== 'Enter') return;
        e.preventDefault();
        const page = parseInt(pageInputMain.value, 10);
        if (!page || page < 1) return;
        handleJump(page);
        pageInputMain.blur();
      });
    }
    if (openTabMain) {
      openTabMain.addEventListener('click', function() {
        if (!currentPdf) return;
        const mode = getMode();
        const inputPage = parseInt(pageInputMain && pageInputMain.value, 10);
        if (mode === 'book' && inputPage && inputPage >= 1) {
          ensureTotals().then(function(t) {
            if (!t || !t.total || inputPage > t.total) return;
            const target = findByGlobalPage(inputPage);
            if (!target) return;
            const targetUrl = normalizeForActions(target.href) + '#page=' + toPdfPage(target.href, target.page);
            window.open(targetUrl, '_blank');
          });
          return;
        }
        if (inputPage && inputPage >= getMinLogical(currentPdf)) {
          const targetUrl = normalizeForActions(currentPdf) + '#page=' + toPdfPage(currentPdf, inputPage);
          window.open(targetUrl, '_blank');
          return;
        }
        const targetUrl = normalizeForActions(currentPdf) + '#page=' + currentPage;
        window.open(targetUrl, '_blank');
      });
    }
    if (focusBtn && focusExitBtn) {
      const syncFocus = function() {
        const on = document.body.classList.contains('desktop-focus');
        focusBtn.style.display = on ? 'none' : '';
        focusExitBtn.style.display = on ? '' : 'none';
      };
      focusBtn.addEventListener('click', function() {
        document.body.classList.add('desktop-focus');
        if (document.body.classList.contains('mobile-focus')) {
          document.body.classList.remove('mobile-focus');
        }
        syncFocus();
      });
      focusExitBtn.addEventListener('click', function() {
        document.body.classList.remove('desktop-focus');
        syncFocus();
      });
      syncFocus();
    }
    if (pageInputMobile) {
      pageInputMobile.addEventListener('keydown', function(e) {
        if (e.key !== 'Enter') return;
        e.preventDefault();
        const page = parseInt(pageInputMobile.value, 10);
        if (!page || page < 1) return;
        handleJump(page);
        pageInputMobile.blur();
      });
    }
    if (fsMobile) {
      fsMobile.addEventListener('click', function() {
        document.body.classList.toggle('mobile-focus');
        if (document.body.classList.contains('desktop-focus')) {
          document.body.classList.remove('desktop-focus');
        }
        if (focusExitFab) focusExitFab.style.display = document.body.classList.contains('mobile-focus') ? 'inline-flex' : '';
      });
    }
    if (focusExitFab) {
      focusExitFab.addEventListener('click', function() {
        document.body.classList.remove('mobile-focus');
        document.body.classList.remove('desktop-focus');
        focusExitFab.style.display = '';
        if (focusBtn && focusExitBtn) {
          focusBtn.style.display = '';
          focusExitBtn.style.display = 'none';
        }
      });
    }
    document.addEventListener('keydown', function(e) {
      if (e.key !== 'Escape') return;
      if (document.body.classList.contains('desktop-focus')) {
        document.body.classList.remove('desktop-focus');
        if (focusBtn && focusExitBtn) {
          focusBtn.style.display = '';
          focusExitBtn.style.display = 'none';
        }
      }
      if (document.body.classList.contains('mobile-focus')) {
        document.body.classList.remove('mobile-focus');
      }
      if (focusExitFab) focusExitFab.style.display = '';
    });
    document.addEventListener('keydown', function(e) {
      if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
      const t = e.target;
      const tag = t && t.tagName ? t.tagName.toLowerCase() : '';
      if (tag === 'input' || tag === 'textarea' || tag === 'select') return;
      if (e.key === 'ArrowLeft') changePage(currentPage - 1);
      if (e.key === 'ArrowRight') changePage(currentPage + 1);
    });
    let touchStartX = 0;
    let touchStartY = 0;
    if (viewer) {
      viewer.addEventListener('touchstart', function(e) {
        if (!e.touches || e.touches.length !== 1) return;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }, { passive: true });
      viewer.addEventListener('touchend', function(e) {
        if (!e.changedTouches || e.changedTouches.length !== 1) return;
        const dx = e.changedTouches[0].clientX - touchStartX;
        const dy = e.changedTouches[0].clientY - touchStartY;
        if (Math.abs(dx) < 60 || Math.abs(dx) < Math.abs(dy)) return;
        if (dx < 0) changePage(currentPage + 1);
        if (dx > 0) changePage(currentPage - 1);
      }, { passive: true });
      viewer.addEventListener('click', function(e) {
        if (window.innerWidth > 768) return;
        const rect = viewer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        if (x < rect.width * 0.5) {
          changePage(currentPage - 1);
        } else {
          changePage(currentPage + 1);
        }
      });
    }
  }

  function buildMobileDropdown() {
    const select = document.getElementById('chapter-select');
    const openTabBtn = document.getElementById('mobile-open-tab');
    if (!select) return;
    select.innerHTML = '';
    const links = document.querySelectorAll('.chapter-link');
    links.forEach(function(a) {
      const opt = document.createElement('option');
      opt.value = a.href;
      opt.textContent = (a.textContent || '').trim();
      select.appendChild(opt);
    });
    if (select.options.length > 0) {
      const state = loadState();
      if (state.lastPdf) {
        const idx = Array.prototype.findIndex.call(select.options, function(opt) {
          return normalizeForActions(opt.value) === normalizeForActions(state.lastPdf);
        });
        select.selectedIndex = idx >= 0 ? idx : 0;
      } else {
        select.selectedIndex = 0;
      }
    }
    select.addEventListener('change', function() {
      const opt = select.options[select.selectedIndex];
      if (!opt) return;
      openPdf(opt.value);
    });
    if (openTabBtn) {
      openTabBtn.addEventListener('click', function() {
        const opt = select.options[select.selectedIndex];
        if (!opt) return;
        const mode = getMode();
        const url = normalizeForActions(opt.value);
        const inputPage = parseInt(pageInputMobile && pageInputMobile.value, 10);
        if (mode === 'book' && inputPage && inputPage >= 1) {
          ensureTotals().then(function(t) {
            if (!t || !t.total || inputPage > t.total) return;
            const target = findByGlobalPage(inputPage);
            if (!target) return;
            const targetUrl = normalizeForActions(target.href) + '#page=' + toPdfPage(target.href, target.page);
            window.open(targetUrl, '_blank');
          });
          return;
        }
        if (inputPage && inputPage >= getMinLogical(opt.value)) {
          const normalized = normalizePath(opt.value);
          const targetPage = toPdfPage(normalized, inputPage);
          window.open(url + '#page=' + targetPage, '_blank');
          return;
        }
        const state = loadState();
        const normalized = normalizePath(opt.value);
        const saved = state.pages && parseInt(state.pages[normalized], 10);
        const logical = saved || 1;
        const page = (normalized === currentPdf && currentPage) ? currentPage : toPdfPage(normalized, logical);
        window.open(url + '#page=' + page, '_blank');
      });
    }
    // download button removed
  }

  function fixChapterLinks() {
    document.querySelectorAll('.chapter-link').forEach(function(a) {
      const raw = a.getAttribute('href');
      if (!raw) return;
      const cleaned = normalizePath(raw.trim());
      a.setAttribute('href', cleaned);
    });
  }
  function setActiveLink(href) {
    const normalized = normalizePath(href || '');
    const links = document.querySelectorAll('.chapter-link');
    links.forEach(function(a) {
      const raw = a.getAttribute('href') || a.href || '';
      const linkNorm = normalizePath(raw);
      if (linkNorm === normalized) {
        a.classList.add('active');
      } else {
        a.classList.remove('active');
      }
    });
  }

  function init() {
    const initState = loadState();
    initState.pageMode = 'book';
    saveState(initState);
    bindNav();
    buildMobileDropdown();
    fixChapterLinks();
    updateModeUI();
    ensureTotals().then(function() {
      setPageInputs();
    });
    const state = loadState();
    if (state.lastPdf) {
      openPdf(state.lastPdf);
      return;
    }
    const firstLink = document.querySelector('.chapter-link');
    if (firstLink) openPdf(firstLink.href);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  let resizeTimer = null;
  window.addEventListener('resize', function() {
    if (!pdfDoc) return;
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(function() { renderPage(currentPage); }, 150);
  });
})();
</script>
</body>
</html>

